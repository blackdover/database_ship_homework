# 4 系统设计与实现

## 4.1 应用总体架构设计

- 架构风格：基于 Django 的 MVC（更准确为 MTV）架构。后端负责数据模型与数据库视图，前端使用 Django 模板渲染，管理界面使用 Django Admin（simpleui），运维脚本提供命令行工具支持。
- 系统组件：数据库（MySQL，使用视图封装复杂联表）、模型层（Django ORM）、视图层（Django views + 模板）、管理后台（admin/simpleui）、缓存（Django cache），以及运维脚本（用户同步、密码重置）。
- 系统架构图（简洁 mermaid）：

```mermaid
flowchart TB
  User[浏览器用户] -->|HTTP| DjangoViews[管理/仪表盘视图]
  DjangoViews -->|ORM| Models[Models (Yard, Slot, Container...)]
  Models -->|SQL| MySQL[(MySQL)]
  MySQL -->|VIEWs| View_SQL[DB Views (View_Yard_Inventory_Live...)]
  DjangoViews -->|模板渲染| Templates[Templates (dashboard...)]
  Admin[管理员(simpleui)] --> DjangoViews
  CLI[运维脚本] --> MySQL
  Cache[(Django Cache)] <--> DjangoViews
```

## 4.2 核心功能模块

模块说明均包括：代码节选（来自仓库）+ 逐段中文解释（在原基础上扩展说明并每段增加约 50 字）。

模块 1：堆场实时库存视图 — `View_Yard_Inventory_Live`

```252:273:sqlutil/init_database.sql
/* 视图1: View_Yard_Inventory_Live - 堆场实时库存 */
CREATE OR REPLACE VIEW `View_Yard_Inventory_Live` AS
SELECT
    yb.Block_Name AS 堆场区,
    ys.Bay_Number AS 贝位,
    ys.Row_Number AS 排号,
    slot.Tier_Number AS 层号,
    slot.Slot_Coordinates AS 坐标代码,
    cm.Container_Number AS 箱号,
    cm.Current_Status AS 箱状态,
    ct.Type_Code AS ISO代码,
    ct.Nominal_Size AS 尺寸_英尺,
    ct.Group_Code AS 箱型组,
    p.Party_Name AS 箱主,
    p.SCAC_Code AS 箱主代码
FROM `Yard_Slot` slot
JOIN `Container_Master` cm ON slot.Current_Container_ID = cm.Container_Master_ID
JOIN `Container_Type_Dict` ct ON cm.Type_Code = ct.Type_Code
JOIN `Yard_Stack` ys ON slot.Stack_ID = ys.Stack_ID
JOIN `Yard_Block` yb ON ys.Block_ID = yb.Block_ID
LEFT JOIN `Party` p ON cm.Owner_Party_ID = p.Party_ID
WHERE slot.Current_Container_ID IS NOT NULL;
```

如上所示，`View_Yard_Inventory_Live` 将堆场三维坐标（堆场区/贝位/排号/层号/坐标代码）与当前占位的集装箱信息、集装箱类型字典和箱主信息联立，输出一张扁平化的实时库存视图。该视图在数据库层完成多表连接与字段映射，减少应用层的联表复杂度，确保前端和报表使用统一的数据格式。扩展说明：把联表逻辑下沉到数据库视图还有利于使用数据库的优化器进行查询计划优化，便于对报表查询做索引和权限隔离，并降低网络传输负载。视图的只读属性也有利于并发读取场景下的性能稳定性。

模块 2：堆场顶层分区模型 — `YardBlock`

```53:71:container_management/management/models.py
# 堆场区
class YardBlock(models.Model):
    block_id = models.AutoField(primary_key=True, db_column='Block_ID')
    block_name = models.CharField(max_length=50, unique=True, db_column='Block_Name', verbose_name='名称')
    block_type = models.CharField(
        max_length=20,
        choices=BLOCK_TYPE_CHOICES,
        default="Standard",
        db_column='Block_Type',
        verbose_name='类型',
    )
```

`YardBlock` 表示堆场的顶层分区，包含唯一的 `block_name` 与 `block_type` 枚举。它作为堆场拓扑的根节点，被 `YardStack` 作为外键引用以构建物理布局。扩展说明：在实际运营中，不同 `block_type`（例如冷藏、重载）会对应不同的操作规范与设备约束，因此在模型层明确区分有助于后续在业务逻辑或调度模块中对这些分区实施差异化处理（例如冷藏区需要温控约束、特定堆垛优先级等），同时也便于权限或报表按分区统计。

模块 3：堆栈与箱位模型 — `YardStack` / `YardSlot`

```179:193:container_management/management/models.py
# 堆场堆栈
class YardStack(models.Model):
    stack_id = models.AutoField(primary_key=True, db_column='Stack_ID')
    block_id = models.ForeignKey(YardBlock, on_delete=models.CASCADE, db_column='Block_ID', verbose_name='所属堆场区')
    bay_number = models.IntegerField(db_column='Bay_Number', verbose_name='贝位号')
    row_number = models.IntegerField(db_column='Row_Number', verbose_name='排号')
```

```213:236:container_management/management/models.py
# 箱位
class YardSlot(models.Model):
    slot_id = models.AutoField(primary_key=True, db_column='Slot_ID')
    stack_id = models.ForeignKey(YardStack, on_delete=models.CASCADE, db_column='Stack_ID', verbose_name='所属堆栈')
    tier_number = models.IntegerField(db_column='Tier_Number', verbose_name='层号')
    slot_coordinates = models.CharField(max_length=50, unique=True, db_column='Slot_Coordinates', verbose_name='坐标')
    SLOT_STATUS_CHOICES = [
        ("Available", "可用"),
        ("Occupied", "占用"),
        ("Reserved", "预留"),
        ("Maintenance", "维护"),
    ]
    slot_status = models.CharField(
        max_length=20,
        choices=SLOT_STATUS_CHOICES,
        default="Available",
        db_column='Slot_Status',
        verbose_name='状态',
    )
    current_container_id = models.OneToOneField(ContainerMaster, on_delete=models.SET_NULL, null=True, blank=True,
                                                db_column='Current_Container_ID', verbose_name='当前集装箱')
```

`YardStack` 定位于某堆场区下的贝位与排号，`YardSlot` 表示具体的层位（tier）与坐标，并通过 `current_container_id` 记录当前占位容器（OneToOne，确保唯一占用）。扩展说明：该模型组合可精确表达堆场的 3D 物理结构（block -> bay -> row -> tier），并通过 `slot_status` 支持预留、维护等运营场景。在业务实现中，这种结构有利于实现路径规划、设备调度（如堆高机/叉车）以及批量移动任务的原子操作和一致性检查。

模块 4：集装箱主数据与类型字典 — `ContainerMaster` 与 `ContainerTypeDict`

```108:121:container_management/management/models.py
# 集装箱类型字典
class ContainerTypeDict(models.Model):
    type_code = models.CharField(max_length=4, primary_key=True, db_column='Type_Code', verbose_name='ISO类型代码')
    nominal_size = models.IntegerField(db_column='Nominal_Size', verbose_name='名义尺寸')
    group_code = models.CharField(max_length=4, db_column='Group_Code', verbose_name='组代码')
    standard_tare_kg = models.DecimalField(max_digits=8, decimal_places=2, null=True, blank=True, db_column='Standard_Tare_KG', verbose_name='标准皮重')
```

```160:176:container_management/management/models.py
# 集装箱主数据
class ContainerMaster(models.Model):
    container_master_id = models.AutoField(primary_key=True, db_column='Container_Master_ID')
    container_number = models.CharField(max_length=11, unique=True, db_column='Container_Number', verbose_name='箱号')
    owner_party_id = models.ForeignKey(Party, on_delete=models.SET_NULL, null=True, blank=True, db_column='Owner_Party_ID', verbose_name='箱主')
    type_code = models.ForeignKey(ContainerTypeDict, on_delete=models.PROTECT, db_column='Type_Code', verbose_name='类型代码')
    current_status = models.CharField(max_length=20, null=True, blank=True, db_column='Current_Status',
                                      choices=[('InYard', '在堆场'), ('OnVessel', '在船上'), ('GateOut', '已出闸')],
                                      verbose_name='当前状态')
```

`ContainerTypeDict` 保存 ISO 类型、尺寸、组别与标准皮重等静态信息，`ContainerMaster` 保存具体容器实例并通过 `type_code` 关联类型字典。扩展说明：这种字典化设计便于统计按类型/尺寸的分布、快速生成重量与装载配置，支持在调度或配载模块中根据箱型做约束（例如 40ft 与 20ft 的堆放规则不同），同时通过 `on_delete=PROTECT` 保护字典记录不被误删，保证数据完整性。

模块 5：仪表盘统计与视图样本抓取（缓存） — `dashboard_stats` 与 `fetch_view_sample`

```13:29:container_management/management/dashboard_context.py
def dashboard_stats(request):
    """
    为 simpleui 首页提供基础统计数据：
    - 任务按状态分布
    - 集装箱按当前状态分布
    - 关键指标数字
    - 最近船舶访问
    """
    # 任务状态统计
    task_stats_qs = (
        Task.objects.values('status')
        .annotate(total=Count('task_id'))
        .order_by('status')
    )
    task_status_stats = [
        {'name': item['status'], 'value': item['total']} for item in task_stats_qs
    ]
```

```68:92:container_management/management/dashboard_context.py
    def fetch_view_sample(view_name, columns, limit=5):
        """
        从指定的数据库视图查询若干行样本并返回 {'columns': [...], 'rows': [{col:val}, ...]}
        使用缓存避免频繁查询。
        """
        cache_key = f'dashboard_view_sample:{view_name}'
        cached = cache.get(cache_key)
        if cached is not None:
            return cached

        cols_sql = ', '.join([f'`{c}`' for c in columns])
        sql = f"SELECT {cols_sql} FROM `{view_name}` LIMIT {limit}"
        try:
            with connection.cursor() as cur:
                cur.execute(sql)
                rows = cur.fetchall()
                colnames = [d[0] for d in cur.description] if cur.description else []
            rows_list = [list(row) for row in rows]
            data = {'columns': colnames, 'rows': rows_list}
            cache.set(cache_key, data, 60)  # 缓存 60s
            return data
```

`dashboard_stats` 使用 ORM 聚合获得 KPI 和图表数据，同时调用 `fetch_view_sample` 从数据库视图抓取样本数据用于仪表盘小表格展示。`fetch_view_sample` 使用原生 cursor 执行 SELECT，并对结果进行缓存（默认 60s）以减少频繁的视图查询。扩展说明：该设计折衷实时性与性能，适用于仪表盘这种对“可示例化数据”要求高于严格实时性的场景。缓存策略可根据并发量、数据变更频率进一步调整为按视图或按表刷新。

模块 6：自定义认证、会话与业务用户同步 — `custom_login`

```33:46:container_management/management/auth_views.py
        # 使用Django的认证系统
        user = authenticate(request, username=username, password=password)

        if user is not None:
            django_login(request, user)

            # 获取数据库中的用户信息
            try:
                db_user = Users.objects.get(username=username)
                request.session['user_id'] = db_user.user_id
                request.session['user_full_name'] = db_user.full_name or username
                request.session['user_role'] = get_user_role(db_user.user_id, django_user=user)
                request.session['user_permissions'] = get_user_permission_names(db_user.user_id)
```

```79:88:container_management/management/auth_views.py
                    with transaction.atomic():
                        db_user = Users.objects.create(
                            username=username,
                            email=email,
                            full_name=user.get_full_name() or username,
                            hashed_password=b'',  # 不存储密码，使用Django认证
                            is_active=user.is_active
                        )
```

登录流程先使用 Django 原生认证（authenticate），成功后将 Django 用户与业务侧 `Users` 表同步：如果 `Users` 中不存在记录，会在事务内自动创建并写入 session 中的 `user_id`, `user_permissions`, `user_role` 等信息。扩展说明：这种做法兼顾了 Django Admin 与业务权限体系，使得在不改动 Django auth 的情况下仍能维护独立业务用户表，用于记录更丰富的业务字段（如 `party` 关系、全名等），并通过事务保证同步过程的原子性，减少因并发导致的数据不一致风险。此外，对超级用户的特殊处理（自动注入 ADMIN 权限）便于管理员操作。

模块 7：Django Admin 集成与查询定制

```93:98:container_management/management/admin.py
@admin.register(YardSlot)
class YardSlotAdmin(admin.ModelAdmin):
    list_display = ['slot_id', 'stack_id', 'tier_number', 'slot_coordinates', 'slot_status', 'current_container_id']
    list_filter = ['slot_status', 'stack_id__block_id']
    search_fields = ['slot_coordinates']
    list_per_page = 20
```

```109:113:container_management/management/admin.py
    def get_queryset(self, request):
        qs = super().get_queryset(request)
        # Keep rows where berth is NULL OR berth.port_id == port_id
        return qs.filter(Q(berth_id__isnull=True) | Q(berth_id__port_id=F('port_id')))
```

Admin 为多数核心模型提供可视化管理和搜索过滤，`YardSlotAdmin` 暴露了必要字段用于快速查看箱位与占用状态；同时针对 `VesselVisit` 的 `get_queryset` 做了定制过滤以避免因外键或时区表缺失导致异常。扩展说明：通过 Admin 的定制化列表/过滤/搜索，运维人员可以在无需编写 SQL 的情况下快速定位问题、进行数据修正或导出。结合 simpleui 的主题，美化后的 Admin 提高了日常运维效率；对于复杂查询还可扩展 admin actions 或自定义视图。

模块 8：运维脚本工具 — `sync_user.py` 与 `reset_password.py`

```19:27:container_management/sync_user.py
def sync_user_to_db(django_username):
    """将Django用户同步到数据库Users表"""
    try:
        # 获取Django用户
        django_user = User.objects.get(username=django_username)

        # 检查Users表中是否已存在
        if Users.objects.filter(username=django_username).exists():
            db_user = Users.objects.get(username=django_username)
            print(f'✅ 用户 "{django_username}" 在Users表中已存在')
```

```17:23:container_management/reset_password.py
def reset_password(username, new_password):
    """重置用户密码"""
    try:
        user = User.objects.get(username=username)
        user.set_password(new_password)
        user.save()
        print(f'✅ 用户 "{username}" 的密码已成功重置！')
```

项目提供 CLI 工具用于同步 Django auth 用户到业务 `Users` 表并安全重置密码。`sync_user.py` 处理 email 冲突、缺失 email 的默认填充，并在事务中创建业务用户；`reset_password.py` 则支持快速重置与批量运维操作。扩展说明：这些脚本对运维场景尤为关键，减少直接数据库操作的风险，并能在部署或紧急恢复时快速恢复管理员访问权限。它们也为自动化部署或运维 playbook（如 Ansible）提供了可调用的步骤接口。

模块 9（新增）：任务模型与任务详情视图 — `Task` / `View_Task_Details`

```311:369:container_management/management/models.py
# 任务表
class Task(models.Model):
     task_id = models.AutoField(primary_key=True, db_column='Task_ID')
     task_type = models.CharField(
         max_length=30,
         db_column='Task_Type',
         choices=[
             ('Load', '装船'),
             ('Discharge', '卸船'),
             ('Move', '移箱'),
             ('GateIn', '进闸'),
             ('GateOut', '出闸'),
         ],
         verbose_name='任务类型',
     )
     status = models.CharField(
         max_length=20,
         default='Pending',
         db_column='Status',
         choices=[
             ('Pending', '待处理'),
             ('InProgress', '进行中'),
             ('Completed', '已完成'),
             ('Cancelled', '已取消'),
         ],
         verbose_name='状态',
     )
     container_master_id = models.ForeignKey(
         ContainerMaster, on_delete=models.CASCADE, db_column='Container_Master_ID', verbose_name='集装箱'
     )
     from_slot_id = models.ForeignKey(
         YardSlot, on_delete=models.CASCADE, related_name='tasks_from', db_column='From_Slot_ID', verbose_name='起始箱位'
     )
     to_slot_id = models.ForeignKey(
         YardSlot, on_delete=models.CASCADE, related_name='tasks_to', db_column='To_Slot_ID', verbose_name='目标箱位'
     )
```

```275:319:sqlutil/init_database.sql
/* 视图2: View_Task_Details - 任务详情视图 */
CREATE OR REPLACE VIEW `View_Task_Details` AS
SELECT
    t.Task_ID AS 任务编号,
    t.Task_Type AS 任务类型,
    t.Status AS 任务状态,
    t.Priority AS 优先级,
    t.Movement_Timestamp AS 实际执行时间,
    cm.Container_Number AS 箱号,
    cm.Current_Status AS 箱状态,
    ct.Type_Code AS 箱型代码,
    ct.Nominal_Size AS 箱尺寸,
    yb_from.Block_Name AS 起始堆场区,
    ys_from.Bay_Number AS 起始贝位,
    ys_from.Row_Number AS 起始排号,
    slot_from.Tier_Number AS 起始层号,
    slot_from.Slot_Coordinates AS 起始坐标,
    yb_to.Block_Name AS 目标堆场区,
    ys_to.Bay_Number AS 目标贝位,
    ys_to.Row_Number AS 目标排号,
    slot_to.Tier_Number AS 目标层号,
    slot_to.Slot_Coordinates AS 目标坐标,
    vm.Vessel_Name AS 船舶名称,
    vv.Voyage_Number_In AS 进口航次,
    vv.Voyage_Number_Out AS 出口航次,
    u_creator.Username AS 创建人,
    u_creator.Full_Name AS 创建人姓名,
    u_assigned.Username AS 指派给,
    u_assigned.Full_Name AS 指派给姓名,
    u_executor.Username AS 执行人,
    u_executor.Full_Name AS 执行人姓名
FROM `Task` t
JOIN `Container_Master` cm ON t.Container_Master_ID = cm.Container_Master_ID
JOIN `Container_Type_Dict` ct ON cm.Type_Code = ct.Type_Code
JOIN `Yard_Slot` slot_from ON t.From_Slot_ID = slot_from.Slot_ID
JOIN `Yard_Stack` ys_from ON slot_from.Stack_ID = ys_from.Stack_ID
JOIN `Yard_Block` yb_from ON ys_from.Block_ID = yb_from.Block_ID
JOIN `Yard_Slot` slot_to ON t.To_Slot_ID = slot_to.Slot_ID
JOIN `Yard_Stack` ys_to ON slot_to.Stack_ID = ys_to.Stack_ID
JOIN `Yard_Block` yb_to ON ys_to.Block_ID = yb_to.Block_ID
LEFT JOIN `Vessel_Visit` vv ON t.Vessel_Visit_ID = vv.Vessel_Visit_ID
LEFT JOIN `Vessel_Master` vm ON vv.Vessel_ID = vm.Vessel_ID
JOIN `Users` u_creator ON t.Created_By_User_ID = u_creator.User_ID
LEFT JOIN `Users` u_assigned ON t.Assigned_User_ID = u_assigned.User_ID
LEFT JOIN `Users` u_executor ON t.Actual_Executor_ID = u_executor.User_ID;
```

`Task` 模型记录了调度与执行任务（装船/卸船/移箱等），并通过 `from_slot_id` / `to_slot_id` 指向箱位。`View_Task_Details` 将任务与箱位、箱型、航次和用户信息展开为一张详细视图，便于报表与操作员查看。扩展说明：将任务信息通过视图扁平化，便于在仪表盘/任务面板中快速展示完整上下文，减少多次联表查询和前端的数据拼接负担。该视图也有利于审计和历史回溯（例如按执行人或时间过滤），并能支持任务批量导出与 SLA 统计。

模块 10（新增）：堆场可用空位视图 — `View_Yard_Available_Slots`

```520:538:sqlutil/init_database.sql
/* 视图11: View_Yard_Available_Slots - 堆场空位视图 */
CREATE OR REPLACE VIEW `View_Yard_Available_Slots` AS
SELECT
    yb.Block_ID AS 堆场区编号,
    yb.Block_Name AS 堆场区名称,
    yb.Block_Type AS 堆场区类型,
    ys.Stack_ID AS 堆栈编号,
    ys.Bay_Number AS 贝位,
    ys.Row_Number AS 排号,
    slot.Slot_ID AS 箱位编号,
    slot.Tier_Number AS 层号,
    slot.Slot_Coordinates AS 坐标代码,
    slot.Slot_Status AS 箱位状态
FROM `Yard_Slot` slot
JOIN `Yard_Stack` ys ON slot.Stack_ID = ys.Stack_ID
JOIN `Yard_Block` yb ON ys.Block_ID = yb.Block_ID
WHERE slot.Current_Container_ID IS NULL
    AND slot.Slot_Status = 'Available'
ORDER BY yb.Block_Name, ys.Bay_Number, ys.Row_Number, slot.Tier_Number;
```

该视图返回所有“空闲且可用”的箱位，包含堆场区、堆栈定位及坐标信息，便于调度系统或前端进行就近配位与可视化空位热图。扩展说明：在调度与堆位分配模块中，快速获取可用空位非常关键；该视图通过过滤 `Current_Container_ID IS NULL` 与 `Slot_Status = 'Available'` 保证只返回可即刻使用的箱位，并通过 ORDER BY 提供稳定的排序以支持分页与前端展示。结合额外的优先策略（如空位距离、设备可达性）可以进一步在应用层做二次选择。

## 4.3 关键技术点

- 数据库视图优化：使用 MySQL 视图（例如 `View_Yard_Inventory_Live`, `View_Task_Details`, `View_Yard_Available_Slots`）封装复杂联表逻辑，提供统一、稳定的只读查询接口，便于报表与前端复用并且利于数据库层面优化索引与权限控制。视图设计同时有利于数据一致性与安全隔离。
- 模型设计与约束：堆场以 `YardBlock -> YardStack -> YardSlot` 的层次化模型表达物理拓扑，使用外键、唯一约束与事务（例如同步用户、任务创建）保证业务操作的一致性与数据完整性。
- 缓存与性能：仪表盘使用 `fetch_view_sample` 对数据库视图进行采样查询并缓存（60s），以平衡实时性和数据库负载；可扩展为分层缓存或按视图 TTL 精细化设置。
- 安全与认证：采用 Django 原生认证，不在业务表保存明文密码（`Users.hashed_password` 作为占位），登录后同步业务用户数据并将权限写入 session，确保应用层权限判断可靠且与 Django Admin 一致。
- 管理后台与运维：使用 Django Admin（simpleui 主题）提供对核心实体（箱位、箱、任务等）的可视化管理；配套的 CLI 工具（`sync_user.py`, `reset_password.py`）实现常用运维操作的自动化与可重复性。
- 可扩展性与维护：将查询逻辑分层（视图 + ORM +模板），便于各层独立演进；字典表（箱型）和视图的解耦化设计支持在不改动业务代码的情况下扩展新的统计或视图。

## 交付与后续

- 我已按要求生成本 Markdown 文档，并为每个 Django 相关模块扩展了说明（每段在原有基础上增加约 50 字中文说明），并新增两个模块（任务模型/任务详情视图与堆场空位视图）。
- 如果需要我可以将该文档进一步导出为 PDF/Word 或提交为仓库变更，请告知目标路径或格式。

## 4.4 扩展模块（聚焦 Python 与 HTML）

下面补充 5 个针对 Python 文件与前端模板的模块说明，重点说明实现细节、设计考量与在系统中的作用。

模块 11：仪表盘模板（管理员主题） — `admin/simpleui/dashboard_content.html`

```97:106:container_management/management/templates/admin/simpleui/dashboard_content.html
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    {{ task_status_stats|json_script:"task_status_stats_json" }}
    {{ container_status_stats|json_script:"container_status_stats_json" }}
    {{ recent_visits|json_script:"recent_visits_json" }}
```

```228:256:container_management/management/templates/admin/simpleui/dashboard_content.html
    {% for vname, sample in db_view_samples.items %}
    <div class="card-plain" style="margin-bottom:12px;">
        <h4 style="margin: 0 0 8px;">{{ sample.display_name }}</h4>
        ...
        {% for row in sample.rows %}
            <tr>
                {% for cell in row %}
                    <td>{{ cell|default:"-" }}</td>
                {% endfor %}
            </tr>
        {% endfor %}
    </div>
    {% endfor %}
```

解释：模板将后端传入的统计数据通过 `json_script` 安全注入到页面，并在前端用 Chart.js 渲染可视化图表；同时循环 `db_view_samples` 渲染来自多个数据库视图的样本表格，展示统一的数据样式。扩展说明：这种前后端分工使得模板保持轻量，只做展示与微量数据变换，复杂的数据聚合与安全过滤由后端完成；在前端使用 `json_script` 能避免 XSS 注入风险，同时便于利用现成的图表库进行动态渲染与交互增强。

模块 12：仪表盘外壳模板 — `admin/simpleui/dashboard.html`

```1:6:container_management/management/templates/admin/simpleui/dashboard.html
{% extends "admin/base_site.html" %}
{% load static %}

{% block content %}
    {% include "admin/simpleui/dashboard_content.html" %}
{% endblock %}
```

解释：该文件作为 Admin 仪表盘的最外层模板，仅负责继承 Admin 的基础布局并包含仪表盘内容片段，体现了 Django 模板的组合复用。扩展说明：将内容与外壳分离使得在不同主题或布局下复用同一套仪表盘片段变得简单，可在不同角色或设备下切换外壳模板以满足响应式或权限差异化展示。

模块 13：聚合搜索视图 — `aggregate_search`（`views.py`）

```14:83:container_management/management/views.py
@login_required
@user_passes_test(lambda u: u.is_staff)
def aggregate_search(request):
    """
    聚合搜索页：一个输入框同时查询多个核心模型，并给出快捷操作链接。
    """
    query = (request.GET.get('q') or '').strip()
    ...
    containers = (
        ContainerMaster.objects.select_related('type_code', 'owner_party_id')
        .filter(
            Q(container_number__icontains=query)
            | Q(type_code__type_code__icontains=query)
            | Q(owner_party_id__party_name__icontains=query)
        )
        .order_by('-container_master_id')[:10]
    )
    ...
    return render(request, 'management/aggregate_search.html', context)
```

解释：`aggregate_search` 为管理员或 staff 用户提供跨模型的快速搜索能力，使用 `select_related` 减少额外查询并用 `Q` 对多个字段进行 OR 条件匹配，最后截取前 N 条结果以保证响应速度。扩展说明：该视图是运维人员常用的故障排查与定位工具；通过对核心模型（箱、订舱、任务、访问、相关方）统一搜索，可以极大提升日常运维效率。对大流量场景，可进一步引入异步搜索或全文索引（如 Elasticsearch）以提升性能和模糊匹配能力。

模块 14：权限工具与角色判断 — `management/utils.py`

```26:40:container_management/management/utils.py
def get_user_permission_names(user_id):
    """
    获取用户权限名称列表（优化版本，使用视图）
    """
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                SELECT 权限列表
                FROM View_User_Permissions
                WHERE 用户编号 = %s
            """, [user_id])
            row = cursor.fetchone()
            if row and row[0]:
                return [p.strip() for p in row[0].split(',')]
            return []
```

```51:88:container_management/management/utils.py
def require_permission(permission_name):
    """
    装饰器：要求用户拥有指定权限才能访问视图
    """
    def decorator(view_func):
        @wraps(view_func)
        def wrapper(request, *args, **kwargs):
            if not request.user.is_authenticated:
                messages.error(request, '请先登录')
                return redirect('custom_login')
            ...
            if not has_permission(user_id, permission_name):
                messages.error(request, f'您没有权限访问此页面（需要权限：{permission_name}）')
                return redirect('dashboard')
            return view_func(request, *args, **kwargs)
```

```91:116:container_management/management/utils.py
def get_user_role(user_id, django_user=None):
    """
    根据用户权限判断用户角色
    返回：'admin', 'operator', 'viewer', 'guest'
    """
    if django_user and django_user.is_superuser:
        return 'admin'
    if not user_id:
        return 'guest'
    permissions = get_user_permission_names(user_id)
    if 'ADMIN' in permissions:
        return 'admin'
    elif 'CREATE_TASK' in permissions or 'UPDATE_TASK' in permissions:
        return 'operator'
    elif 'VIEW_INVENTORY' in permissions or 'VIEW_STATISTICS' in permissions:
        return 'viewer'
    else:
        return 'guest'
```

解释：工具模块将权限查询下沉至数据库视图 `View_User_Permissions`，并提供装饰器 `require_permission` 以在视图层做权限保护；`get_user_role` 则把权限集合映射为角色类别，供模板与导航逻辑使用。扩展说明：使用视图读取权限字符串并解析成列表能显著减少复杂联表查询在应用层的开销；装饰器模式统一了权限检查流程，也便于未来在钩子中添加审计或权限变更的实时刷新。

模块 15：示例数据与插入脚本 — `insert_sample_data.py`

```30:36:container_management/insert_sample_data.py
def insert_sample_data():
    """插入示例数据"""
    print('=' * 60)
    print('开始插入示例数据...')
    print('=' * 60)

    with transaction.atomic():
        # =========================================
        # 组 1: 基础主数据
        # =========================================
```

```302:319:container_management/insert_sample_data.py
        # 3.1 箱位 (Yard_Slot)
        slots = []
        slot_counter = 0
        for stack in stacks[:10]:  # 只在前10个堆栈创建箱位
            for tier in range(1, 5):  # 层号 1-4
                slot_counter += 1
                coordinates = f"{stack.block_id.block_name}-{stack.bay_number}-{stack.row_number}-{tier}"
                slot, created = YardSlot.objects.get_or_create(
                    stack_id=stack,
                    tier_number=tier,
                    defaults={
                        'slot_coordinates': coordinates,
                        'slot_status': 'Available',
                    }
                )
```

```524:532:container_management/insert_sample_data.py
if __name__ == '__main__':
    try:
        insert_sample_data()
    except Exception as e:
        print(f'\n❌ 插入数据时出错: {str(e)}')
        import traceback
        traceback.print_exc()
        sys.exit(1)
```

解释：脚本通过事务批量创建主数据、依赖主数据、箱位与业务事务表（订舱、任务等），并对复杂的多对多表（如 `User_Permissions`）使用原生 SQL 进行插入。扩展说明：作为测试与演示工具，该脚本覆盖了数据链路的各层级，帮助开发/测试人员快速复现业务场景；同时在写入权限表时采用 `INSERT IGNORE` 避免重复插入，体现了对幂等性的考虑。上线环境可基于该脚本改造为可配置的数据种子或迁移步骤。

---

我已把上述 5 个模块的详细说明追加到文档中。是否需要我把这些模块进一步细化为流程图、类图或补充更多代码上下文（例如更多行号引用或完整函数体）？如果需要，请指定优先级。
