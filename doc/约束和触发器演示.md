## 约束和触发器演示（基于本项目）

### 目的

演示本仓库中自定义约束与触发器的工作方式，以 `database_simple/sqlutil/triggers.sql` 中的触发器为主，给出可复现的操作步骤、示例 SQL 和预期结果，便于演示与教学。

### 前置条件

- 已将 `database_simple` 项目导入并能访问项目数据库（MySQL 5.7+/8.0+，与触发器脚本兼容）。
- 有权在测试库执行 CREATE/TRIGGER/UPDATE/INSERT 等语句。
- 推荐在测试库或本地容器中执行，避免影响生产数据。

---

## 演示总览

1. 根据 `sqlutil/triggers.sql` 中的触发器逐条演示：如何触发、如何观察变化、示例 SQL。
2. 演示自定义约束（示例：箱号格式校验触发器）并用 SQL 验证成功/失败场景。
3. 演示任务完成后的联动更新（集装箱状态、箱位状态、航次关联等）。
4. 提供清理/回滚建议与注意事项。

---

## 演示步骤（按触发器顺序）

注意：下面每一小节都遵循同一陈述模板：  
“针对 <触发器名称> 的触发器，可以通过设置 <触发条件字段> 为 <触发值>，然后更改 <关联字段> 为 <操作值>，<目标表/字段> 应被改变成 <预期结果>。”

### 触发器 1 — `TRG_Task_Complete_Update_Container`

针对任务完成时自动更新集装箱状态的触发器，可以通过将 `Task.Status` 设置为 `Completed`（例如执行 `UPDATE Task SET Status='Completed' WHERE Task_ID=<id>`），并保证该 `Task.Task_Type` 为 `Load` / `Discharge` / `GateOut` / `GateIn`；然后更改任务状态为 `Completed`，`Container_Master.Current_Status` 应被改变成相应状态（`OnVessel`、`InYard`、`GateOut`）。

复现示例（MySQL）：

```sql
-- 假设已有 Task：Task_ID=10, Task_Type='Load', Container_Master_ID=100, Status='InProgress'
UPDATE Task SET Status = 'Completed' WHERE Task_ID = 10;

-- 验证 Container_Master 的状态应变为 OnVessel
SELECT Current_Status FROM Container_Master WHERE Container_Master_ID = 100;
```

预期：查询结果显示 `OnVessel`。

### 触发器 2 — `TRG_Task_Complete_Update_Slot`

针对任务完成时自动更新箱位状态的触发器，可以通过将 `Task.Status` 设置为 `Completed`，然后更改任务的 `From_Slot_ID` 和 `To_Slot_ID` 所指向的 `Yard_Slot`（起始箱位清空、目标箱位设置占用）；`From_Slot` 的 `Current_Container_ID` 应被设置为 `NULL` 且 `Slot_Status` 变为 `Available`，`To_Slot` 的 `Current_Container_ID` 应被设置为该 `Container_Master_ID` 且 `Slot_Status` 变为 `Occupied`。

复现示例：

```sql
-- 假设 Task_ID=20, From_Slot_ID=5, To_Slot_ID=8, Container_Master_ID=200
UPDATE Task SET Status='Completed' WHERE Task_ID=20;

-- 验证起始与目标箱位
SELECT Slot_ID, Current_Container_ID, Slot_Status FROM Yard_Slot WHERE Slot_ID IN (5,8);
```

预期：Slot_ID=5 的 Current_Container_ID 为 NULL，Slot_Status='Available'；Slot_ID=8 的 Current_Container_ID=200，Slot_Status='Occupied'。

### 触发器 3 — `TRG_Container_Validate_Format`

针对集装箱插入时自动验证格式的触发器，可以通过执行 `INSERT INTO Container_Master (...) VALUES (...)` 并把 `Container_Number` 设置为满足或不满足 ISO 格式（4 个大写字母 + 7 位数字，例如 `ABCD1234567`）；若格式不符合（例如 `abc123`），触发器应抛出错误并阻止插入。

复现示例（错误示例）：

```sql
-- 非法箱号插入（应失败）
INSERT INTO Container_Master (Container_Number, /*...*/ ) VALUES ('abc123', /*...*/);

-- 合法箱号插入（应成功）
INSERT INTO Container_Master (Container_Number, /*...*/ ) VALUES ('ABCD1234567', /*...*/);
```

预期：第一次插入抛出 SQL 错误，第二次插入成功并创建记录。

### 触发器 4 — `TRG_Vessel_Visit_Auto_Complete`

针对船舶访问完成时自动更新状态的触发器，可以通过在 `Vessel_Visit` 上设置 `ATD`（实际离港时间）字段非空（例如 `UPDATE Vessel_Visit SET ATD = NOW() WHERE Visit_ID=<id>`）；触发器会把 `Vessel_Visit.Status` 自动更新为 `Completed`。

复现示例：

```sql
UPDATE Vessel_Visit SET ATD = '2025-12-24 12:00:00' WHERE Visit_ID = 300;
SELECT Status FROM Vessel_Visit WHERE Visit_ID = 300;
```

预期：`Status` 字段变为 `Completed`。

### 触发器 5 — `TRG_Task_Set_Default_Priority`

针对任务创建时自动设置创建时间与默认优先级的触发器，可以通过执行 `INSERT INTO Task (...) VALUES (...)` 并在插入语句中不指定 `Priority`（或设为 0/NULL）；触发器会把 `NEW.Priority` 设置为默认值 `100`。

复现示例：

```sql
INSERT INTO Task (Task_Type, Container_Master_ID, From_Slot_ID, To_Slot_ID, Status) VALUES ('Load', 100, 10, 12, 'Pending');

SELECT Task_ID, Priority FROM Task ORDER BY Task_ID DESC LIMIT 1;
```

预期：`Priority` 的值为 `100`（触发器设置）。

### 触发器 6 — `TRG_Booking_Validate_Voyage`

针对订舱单确认时自动关联航次的触发器，可以通过将 `Booking.Status` 更新为 `Confirmed`，同时如果 `Voyage_ID` 为空则触发器会抛出错误阻止该更新；因此要演示可先执行一个失败场景（`Voyage_ID IS NULL`）再演示成功场景（先关联 `Voyage_ID`）。

复现示例（失败）：

```sql
-- 假设 Booking_ID=400, Voyage_ID IS NULL
UPDATE Booking SET Status = 'Confirmed' WHERE Booking_ID = 400;
-- 预期：触发器抛出错误 '订舱单确认时必须关联航次！'
```

复现示例（成功）：

```sql
-- 先关联航次
UPDATE Booking SET Voyage_ID = 50 WHERE Booking_ID = 400;
-- 然后确认
UPDATE Booking SET Status = 'Confirmed' WHERE Booking_ID = 400;
-- 验证：无错误并且 Status = 'Confirmed'
SELECT Status, Voyage_ID FROM Booking WHERE Booking_ID = 400;
```

---

## 示例：完整的演示顺序（最少步骤）

1. 在测试库中确认已加载 `database_simple/sqlutil/triggers.sql`（或手动创建触发器）。
2. 准备测试数据：创建或确认有用于演示的 `Task`、`Container_Master`、`Yard_Slot`、`Vessel_Visit`、`Booking` 等记录，并记录其 ID。
3. 按以上触发器顺序逐条执行示例 UPDATE/INSERT 操作，并用 SELECT 验证目标表字段是否已经按触发器逻辑变更。
4. 对于验证失败的触发器（如格式校验、航次关联），分别执行成功/失败两种场景以便展示触发器阻止操作时的错误信息。

示例 SQL（汇总）：

```sql
-- 触发器 1：完成任务更新集装箱状态
UPDATE Task SET Status='Completed' WHERE Task_ID=10;

-- 触发器 2：完成任务更新箱位
UPDATE Task SET Status='Completed' WHERE Task_ID=20;

-- 触发器 3：非法箱号触发验证失败
INSERT INTO Container_Master (Container_Number, /*...*/ ) VALUES ('WRONG123', /*...*/);

-- 触发器 4：设置 ATD 自动完成 Vessel_Visit
UPDATE Vessel_Visit SET ATD = NOW() WHERE Visit_ID = 300;

-- 触发器 5：插入 Task，默认优先级生效
INSERT INTO Task (Task_Type, Container_Master_ID, From_Slot_ID, To_Slot_ID, Status) VALUES ('Load', 100, 10, 12, 'Pending');

-- 触发器 6：尝试确认 Booking（无 Voyage）会失败
UPDATE Booking SET Status = 'Confirmed' WHERE Booking_ID = 400;
```

---

## 清理/回滚建议

- 在测试库执行 `DROP TRIGGER IF EXISTS <trigger_name>`（按触发器名）以移除测试触发器，或恢复数据库备份。
- 记得撤销测试中插入的示例数据（DELETE）或使用事务/临时数据库来避免污染环境。

## 注意事项

- `sqlutil/triggers.sql` 为 MySQL 风格（`DELIMITER` / `SIGNAL` 等），示例 SQL 也采用 MySQL 兼容的 DML。若你的环境为 PostgreSQL，请使用相应 PL/pgSQL 版本的函数与触发器语法（参见 `doc/操作手册.md` 的 PostgreSQL 示例）。
- 在生产环境使用触发器前请评估性能影响和错误信息的可读性，必要时在应用层额外校验以提供更友好的错误提示。

---

如需，我可以把这些演示步骤拆分为独立的 SQL 脚本（放入 `database_simple/sql/`），并生成一个逐步运行脚本以便现场演示或教学使用。请确认是否需要我继续把演示脚本化并提交到仓库。
